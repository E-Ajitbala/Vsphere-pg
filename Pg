#!/usr/bin/env python3
"""
Enhanced VM Port Group Management Tool
- Fixed VM discovery
- Added NIC configuration backup
- Proper vCenter user tracking in logs
- Supports both standard and VxRail environments
"""

import argparse
import json
import logging
import ssl
import sys
import time
from getpass import getpass
from pyVim.connect import SmartConnect, Disconnect
from pyVmomi import vim
from datetime import datetime

# --- Logging Setup ---
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] [vCenter User:%(vc_user)s] %(message)s",
    handlers=[
        logging.FileHandler(f"vm_portgroup_change_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"),
        logging.StreamHandler()
    ]
)

class VMPortGroupManager:
    def __init__(self):
        self.results = []
        self.port_groups = []
        self.vc_username = None
        self.args = self.parse_args()
        self.vcenters = [
            {"name": "Production vCenter", "host": "vc-prod.example.com"},
            {"name": "DR vCenter", "host": "vc-dr.example.com"}
        ]
        self.execution_start = datetime.now()

    def show_usage_summary(self):
        """Display help summary when no arguments are provided"""
        print("\nVM Port Group Management Tool")
        print("="*50)
        print("Usage examples:")
        print("  Basic interactive mode:")
        print("    python script.py")
        print("  Bulk change all VMs to same port group:")
        print("    python script.py --bulk-mode")
        print("\nKey arguments:")
        print("  --vm-list FILE     Specify VM list file (default: vm_list.txt)")
        print("  --bulk-mode        Apply same port group to all VMs")
        print("  --dry-run          Simulate changes without execution")
        print("  --list-pgs         List available port groups and exit")
        print("  --skip-vxrail      Skip VxRail-managed VMs")
        print("\nLogs include vCenter username and are saved with timestamp")
        sys.exit(0)

    def parse_args(self):
        parser = argparse.ArgumentParser(add_help=False)
        parser.add_argument("--vm-list", default="vm_list.txt", help="File containing VM names")
        parser.add_argument("--dry-run", action="store_true", help="Simulate changes without execution")
        parser.add_argument("--bulk-mode", action="store_true", help="Apply same port group to all VMs")
        parser.add_argument("--list-pgs", action="store_true", help="List available port groups and exit")
        parser.add_argument("--skip-vxrail", action="store_true", help="Skip VxRail-managed VMs")
        parser.add_argument("-h", "--help", action="store_true", help="Show this help message")
        
        if len(sys.argv) == 1:
            self.show_usage_summary()
        
        return parser.parse_args()

    def get_credentials(self):
        print("\n=== vCenter Authentication ===")
        self.vc_username = input("vCenter Username: ")
        return getpass("vCenter Password: ")

    def select_vcenter(self):
        print("\nAvailable vCenter Servers:")
        for i, vc in enumerate(self.vcenters, 1):
            print(f"{i}. {vc['name']} ({vc['host']})")
        
        while True:
            try:
                selection = int(input("Select vCenter: ")) - 1
                if 0 <= selection < len(self.vcenters):
                    return self.vcenters[selection]
                print("Invalid selection. Try again.")
            except ValueError:
                print("Please enter a number.")

    def connect_vcenter(self):
        vc = self.select_vcenter()
        password = self.get_credentials()
        
        try:
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE
            
            si = SmartConnect(
                host=vc["host"],
                user=self.vc_username,
                pwd=password,
                sslContext=ssl_context
            )
            
            # Create logger with vCenter user context
            logger = logging.getLogger()
            for handler in logger.handlers:
                handler.setFormatter(logging.Formatter(
                    "%(asctime)s [%(levelname)s] [vCenter User:%(vc_user)s] %(message)s"
                ))
            
            logging.info(f"Connected to {vc['name']} ({vc['host']})",
                        extra={'vc_user': self.vc_username})
            return si, vc["name"]
        except Exception as e:
            logging.error(f"Connection failed: {str(e)}", extra={'vc_user': self.vc_username})
            exit(1)

    def is_vxrail_vm(self, vm_name):
        return vm_name.startswith(("VxRail-", "VCF-", "ESXi-"))

    def backup_nic_config(self, vm_name, nic_details):
        backup_data = {
            "timestamp": datetime.now().isoformat(),
            "vm": vm_name,
            "nics": nic_details
        }
        filename = f"nic_backup_{vm_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(filename, 'w') as f:
            json.dump(backup_data, f, indent=2)
        logging.info(f"Backed up NIC config for {vm_name} to {filename}",
                    extra={'vc_user': self.vc_username})

    def get_all_vms(self, content):
        vm_view = content.viewManager.CreateContainerView(
            content.rootFolder, [vim.VirtualMachine], True)
        vms = [vm for vm in vm_view.view]
        vm_view.Destroy()
        return vms

    def get_vm_by_name(self, content, vm_name):
        for vm in self.get_all_vms(content):
            if vm.name == vm_name:
                return vm
        return None

    def get_nic_details(self, vm):
        details = []
        for dev in vm.config.hardware.device:
            if isinstance(dev, (vim.vm.device.VirtualEthernetCard, 
                             vim.vm.device.VirtualVmxnet3)):
                backing = None
                if hasattr(dev, 'backing'):
                    backing = dev.backing
                elif hasattr(dev, 'connectable'):
                    backing = dev.connectable.network
                
                if backing and hasattr(backing, 'network'):
                    details.append({
                        "device": dev.deviceInfo.label,
                        "current_pg": backing.network.name,
                        "mac": dev.macAddress,
                        "type": type(dev).__name__,
                        "ip_address": self.get_vm_ip(vm, backing.network.name)
                    })
        return details

    def get_vm_ip(self, vm, network_name):
        if vm.guest and vm.guest.net:
            for net in vm.guest.net:
                if net.network == network_name and net.ipAddress:
                    return net.ipAddress[0]
        return "N/A"

    def change_port_group(self, vm, nic, new_pg):
        for dev in vm.config.hardware.device:
            if dev.deviceInfo.label == nic["device"]:
                spec = vim.vm.ConfigSpec()
                
                if hasattr(dev, 'backing'):
                    dev.backing.network = new_pg
                elif hasattr(dev, 'connectable'):
                    dev.connectable.network = new_pg
                
                spec.deviceChange = [
                    vim.vm.device.VirtualDeviceConfigSpec(
                        device=dev,
                        operation=vim.vm.device.VirtualDeviceConfigSpec.Operation.edit
                    )
                ]
                task = vm.ReconfigVM_Task(spec)
                return task
        return None

    def print_summary(self):
        execution_time = datetime.now() - self.execution_start
        
        print("\n=== Execution Summary ===")
        print(f"vCenter User: {self.vc_username}")
        print(f"Start Time: {self.execution_start.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Duration: {str(execution_time).split('.')[0]}")
        
        print("\n=== Change Summary ===")
        print(f"{'VM':<20} {'NIC':<15} {'Type':<10} {'IP':<15} {'Old PG':<20} {'New PG':<20} {'Status':<10}")
        print("-"*110)
        
        for result in self.results:
            status = "DRY-RUN" if self.args.dry_run and result['changed'] else \
                    "CHANGED" if result['changed'] else "SKIPPED"
            print(f"{result['vm']:<20} {result['nic']:<15} {result.get('type','N/A'):<10} "
                  f"{result.get('ip','N/A'):<15} {result['old_pg']:<20} {result['new_pg']:<20} {status:<10}")

        changed = len([r for r in self.results if r['changed']])
        print(f"\nTotal VMs processed: {len(self.results)}")
        print(f"Port groups changed: {changed}")
        print(f"Dry-run mode: {'Yes' if self.args.dry_run else 'No'}")

    def run(self):
        try:
            si, vcenter_name = self.connect_vcenter()
            content = si.content
            
            if self.args.list_pgs:
                print(f"\nAvailable Port Groups on {vcenter_name}:")
                for pg in sorted(self.get_port_groups(content)):
                    print(f"- {pg}")
                Disconnect(si)
                return

            with open(self.args.vm_list) as f:
                vm_names = [line.strip() for line in f if line.strip()]

            target_pg = None
            if self.args.bulk_mode:
                self.port_groups = self.get_port_groups(content)
                print(f"\nAvailable Port Groups on {vcenter_name}:")
                for i, pg in enumerate(self.port_groups, 1):
                    print(f"{i}. {pg}")
                selection = int(input("Select port group number: ")) - 1
                target_pg = self.port_groups[selection]

            for vm_name in vm_names:
                vm = self.get_vm_by_name(content, vm_name)
                if not vm:
                    logging.warning(f"VM {vm_name} not found", extra={'vc_user': self.vc_username})
                    continue

                if self.args.skip_vxrail and self.is_vxrail_vm(vm_name):
                    logging.info(f"Skipping VxRail-managed VM: {vm_name}", 
                               extra={'vc_user': self.vc_username})
                    self.results.append({
                        "vcenter": vcenter_name,
                        "vm": vm_name,
                        "nic": "N/A",
                        "type": "N/A",
                        "ip": "N/A",
                        "old_pg": "N/A",
                        "new_pg": "N/A",
                        "changed": False
                    })
                    continue

                nics = self.get_nic_details(vm)
                self.backup_nic_config(vm_name, nics)

                for nic in nics:
                    result = {
                        "vcenter": vcenter_name,
                        "vm": vm_name,
                        "nic": nic["device"],
                        "type": nic["type"],
                        "ip": nic["ip_address"],
                        "old_pg": nic["current_pg"],
                        "new_pg": target_pg if self.args.bulk_mode else nic["current_pg"],
                        "changed": False
                    }

                    if not self.args.bulk_mode:
                        print(f"\nVM: {vm_name} | NIC: {nic['device']} ({nic['type']})")
                        print(f"Current Port Group: {nic['current_pg']}")
                        print(f"IP Address: {nic['ip_address']}")
                        print("Available Port Groups:")
                        for i, pg in enumerate(self.get_port_groups(content), 1):
                            print(f"{i}. {pg}")
                        selection = int(input("Select new port group (0 to skip): ")) - 1
                        if selection >= 0:
                            result["new_pg"] = self.port_groups[selection]

                    if result["new_pg"] and result["new_pg"] != result["old_pg"]:
                        if self.args.dry_run:
                            logging.info(
                                f"DRY-RUN: Would change {vm_name} NIC {nic['device']} "
                                f"from {nic['current_pg']} to {result['new_pg']}",
                                extra={'vc_user': self.vc_username}
                            )
                        else:
                            task = self.change_port_group(vm, nic, result["new_pg"])
                            if task:
                                logging.info(
                                    f"Changed {vm_name} NIC {nic['device']} to {result['new_pg']}",
                                    extra={'vc_user': self.vc_username}
                                )
                        result["changed"] = True

                    self.results.append(result)
                time.sleep(1)  # Rate limiting

            self.print_summary()

        except Exception as e:
            logging.error(f"Unexpected error: {str(e)}", extra={'vc_user': self.vc_username})
            sys.exit(1)
        finally:
            try:
                Disconnect(si)
            except:
                pass

if __name__ == "__main__":
    manager = VMPortGroupManager()
    manager.run()
