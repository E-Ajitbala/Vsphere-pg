#!/usr/bin/env python3
"""
VM Port Group Management Tool
- Supports both standard and VxRail environments
- Tracks executing user in logs
- Provides before/after summaries
- Handles multiple vCenter servers
- Includes dry-run mode
"""

import argparse
import logging
import ssl
import sys
import time
from getpass import getpass
from pyVim.connect import SmartConnect, Disconnect
from pyVmomi import vim
import getpass as gt
from datetime import datetime

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] [User:%(user)s] %(message)s",
    handlers=[
        logging.FileHandler(f"vm_portgroup_change_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"),
        logging.StreamHandler()
    ]
)


old_factory = logging.getLogRecordFactory()
def record_factory(*args, **kwargs):
    record = old_factory(*args, **kwargs)
    record.user = gt.getuser()
    return record
logging.setLogRecordFactory(record_factory)

class VMPortGroupManager:
    def __init__(self):
        self.results = []
        self.port_groups = []
        self.args = self.parse_args()
        self.vcenters = [
            {"name": "Production vCenter", "host": "vc-prod.example.com"},
            {"name": "DR vCenter", "host": "vc-dr.example.com"}
        ]
        self.execution_start = datetime.now()

    def show_usage_summary(self):
        """Display help summary when no arguments are provided"""
        print("\nVM Port Group Management Tool")
        print("="*50)
        print("Usage examples:")
        print("  Basic interactive mode:")
        print("    python script.py")
        print("  Bulk change all VMs to same port group:")
        print("    python script.py --bulk-mode")
        print("  Dry-run simulation:")
        print("    python script.py --dry-run")
        print("\nKey arguments:")
        print("  --vm-list FILE     Specify VM list file (default: vm_list.txt)")
        print("  --bulk-mode        Apply same port group to all VMs")
        print("  --dry-run          Simulate changes without execution")
        print("  --list-pgs         List available port groups and exit")
        print("  --skip-vxrail      Skip VxRail-managed VMs")
        print("\nLogs are saved with timestamp in filename")
        sys.exit(0)

    def parse_args(self):
        parser = argparse.ArgumentParser(
            description="VM Port Group Management Tool",
            add_help=False
        )
        parser.add_argument("--vm-list", default="vm_list.txt", help="File containing VM names")
        parser.add_argument("--dry-run", action="store_true", help="Simulate changes without execution")
        parser.add_argument("--bulk-mode", action="store_true", help="Apply same port group to all VMs")
        parser.add_argument("--list-pgs", action="store_true", help="List available port groups and exit")
        parser.add_argument("--skip-vxrail", action="store_true", help="Skip VxRail-managed VMs")
        parser.add_argument("-h", "--help", action="store_true", help="Show this help message")
        
        if len(sys.argv) == 1:
            self.show_usage_summary()
        
        args = parser.parse_args()
        
        if args.help:
            self.show_usage_summary()
        
        return args

    def get_credentials(self):
        print("\n=== vCenter Authentication ===")
        username = input("vCenter Username: ")
        password = getpass("vCenter Password: ")
        return username, password

    def select_vcenter(self):
        print("\nAvailable vCenter Servers:")
        for i, vc in enumerate(self.vcenters, 1):
            print(f"{i}. {vc['name']} ({vc['host']})")
        
        while True:
            try:
                selection = int(input("Select vCenter: ")) - 1
                if 0 <= selection < len(self.vcenters):
                    return self.vcenters[selection]
                print("Invalid selection. Try again.")
            except ValueError:
                print("Please enter a number.")

    def connect_vcenter(self):
        vc = self.select_vcenter()
        username, password = self.get_credentials()
        
        try:
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE
            
            si = SmartConnect(
                host=vc["host"],
                user=username,
                pwd=password,
                sslContext=ssl_context
            )
            logging.info(f"Connected to {vc['name']} ({vc['host']})")
            return si, vc["name"]
        except Exception as e:
            logging.error(f"Connection failed: {str(e)}")
            exit(1)

    def is_vxrail_vm(self, vm_name):
        """Identify VxRail-managed VMs"""
        vxrail_prefixes = ("VxRail-", "VCF-", "ESXi-")
        return vm_name.startswith(vxrail_prefixes)

    def get_port_groups(self, content):
        network_view = content.viewManager.CreateContainerView(
            content.rootFolder, [vim.Network], True)
        self.port_groups = sorted([net.name for net in network_view.view])
        network_view.Destroy()
        return self.port_groups

    def get_vm(self, content, vm_name):
        vm_view = content.viewManager.CreateContainerView(
            content.rootFolder, [vim.VirtualMachine], True)
        for vm in vm_view.view:
            if vm.name == vm_name:
                return vm
        return None

    def get_nic_details(self, vm):
        details = []
        for dev in vm.config.hardware.device:
            if hasattr(dev, 'macAddress'):  # Generic NIC check
                backing = None
                if hasattr(dev, 'backing'):
                    backing = dev.backing
                elif hasattr(dev, 'connectable'):
                    backing = dev.connectable.network
                
                if backing and hasattr(backing, 'network'):
                    details.append({
                        "device": dev.deviceInfo.label,
                        "current_pg": backing.network.name,
                        "mac": dev.macAddress,
                        "type": type(dev).__name__
                    })
        return details

    def change_port_group(self, vm, nic, new_pg):
        for dev in vm.config.hardware.device:
            if dev.deviceInfo.label == nic["device"]:
                spec = vim.vm.ConfigSpec()
                
                if hasattr(dev, 'backing'):
                    dev.backing.network = new_pg
                elif hasattr(dev, 'connectable'):
                    dev.connectable.network = new_pg
                
                spec.deviceChange = [
                    vim.vm.device.VirtualDeviceConfigSpec(
                        device=dev,
                        operation=vim.vm.device.VirtualDeviceConfigSpec.Operation.edit
                    )
                ]
                task = vm.ReconfigVM_Task(spec)
                return task
        return None

    def print_summary(self):
        execution_time = datetime.now() - self.execution_start
        print("\n=== Execution Summary ===")
        print(f"Start Time: {self.execution_start.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Duration: {str(execution_time).split('.')[0]}")
        print(f"Executing User: {gt.getuser()}")
        
        print("\n=== Change Summary ===")
        print(f"{'vCenter':<15} {'VM':<20} {'NIC Type':<12} {'Old PG':<20} {'New PG':<20} {'Status':<10}")
        print("-"*100)
        
        for result in self.results:
            status = "DRY-RUN" if self.args.dry_run and result['changed'] else ("CHANGED" if result['changed'] else "SKIPPED")
            print(f"{result['vcenter']:<15} {result['vm']:<20} {result.get('type','N/A'):<12} "
                  f"{result['old_pg']:<20} {result['new_pg']:<20} {status:<10}")
        
        changed = len([r for r in self.results if r['changed']])
        skipped = len(self.results) - changed
        
        print("\n=== Statistics ===")
        print(f"Total VMs processed: {len(self.results)}")
        print(f"Port groups changed: {changed}")
        print(f"VMs skipped: {skipped}")
        print(f"Dry-run mode: {'Yes' if self.args.dry_run else 'No'}")
        print(f"Skipped VxRail VMs: {'Yes' if self.args.skip_vxrail else 'No'}")

    def run(self):
        try:
            logging.info(f"Starting execution with arguments: {vars(self.args)}")
            
            si, vcenter_name = self.connect_vcenter()
            content = si.content
            
            if self.args.list_pgs:
                print(f"\nAvailable Port Groups on {vcenter_name}:")
                for pg in self.get_port_groups(content):
                    print(f"- {pg}")
                Disconnect(si)
                return

            with open(self.args.vm_list) as f:
                vm_names = [line.strip() for line in f if line.strip()]

            target_pg = None
            if self.args.bulk_mode:
                self.get_port_groups(content)
                print(f"\nAvailable Port Groups on {vcenter_name}:")
                for i, pg in enumerate(self.port_groups, 1):
                    print(f"{i}. {pg}")
                selection = int(input("Select port group number: ")) - 1
                target_pg = self.port_groups[selection]

            for vm_name in vm_names:
                if self.args.skip_vxrail and self.is_vxrail_vm(vm_name):
                    logging.warning(f"Skipping VxRail-managed VM: {vm_name}")
                    self.results.append({
                        "vcenter": vcenter_name,
                        "vm": vm_name,
                        "type": "N/A",
                        "old_pg": "N/A",
                        "new_pg": "N/A",
                        "changed": False
                    })
                    continue

                vm = self.get_vm(content, vm_name)
                if not vm:
                    logging.warning(f"VM {vm_name} not found")
                    continue

                nics = self.get_nic_details(vm)
                for nic in nics:
                    result = {
                        "vcenter": vcenter_name,
                        "vm": vm_name,
                        "nic": nic["device"],
                        "type": nic["type"],
                        "old_pg": nic["current_pg"],
                        "new_pg": target_pg if self.args.bulk_mode else nic["current_pg"],
                        "changed": False
                    }

                    if not self.args.bulk_mode:
                        print(f"\nVM: {vm_name} | NIC: {nic['device']} ({nic['type']})")
                        print(f"Current Port Group: {nic['current_pg']}")
                        print("Available Port Groups:")
                        for i, pg in enumerate(self.get_port_groups(content), 1):
                            print(f"{i}. {pg}")
                        selection = int(input("Select new port group (0 to skip): ")) - 1
                        if selection >= 0:
                            result["new_pg"] = self.port_groups[selection]

                    if result["new_pg"] and result["new_pg"] != result["old_pg"]:
                        if self.args.dry_run:
                            logging.info(f"DRY-RUN: Would change {vm_name} NIC {nic['device']} "
                                       f"from {nic['current_pg']} to {result['new_pg']}")
                        else:
                            task = self.change_port_group(vm, nic, result["new_pg"])
                            if task:
                                logging.info(f"Changed {vm_name} NIC {nic['device']} to {result['new_pg']}")
                        result["changed"] = True

                    self.results.append(result)
                time.sleep(1)  # Rate limiting

            self.print_summary()

        except Exception as e:
            logging.error(f"Unexpected error: {str(e)}")
            sys.exit(1)
        finally:
            try:
                Disconnect(si)
            except:
                pass

if __name__ == "__main__":
    manager = VMPortGroupManager()
    manager.run()
